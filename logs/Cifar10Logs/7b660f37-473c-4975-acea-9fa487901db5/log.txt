====================================================================================================
Experiment mode: <unknown>
====================================================================================================

Accuracy statistics:
  Runs: 25
  Mean: 0.9392
  Std:  0.0011
  Min:  0.9366
  Max:  0.9416

Runtime statistics (seconds):
  Runs: 25
  Mean: 10.7237
  Std:  3.2166
  Min:  9.6039
  Max:  26.4644

Per-run results:
  Run    Accuracy    Time (s)
  ----   --------    --------
    0      0.9393     26.4644
    1      0.9383     10.2362
    2      0.9388      9.6039
    3      0.9377     10.3265
    4      0.9399      9.9877
    5      0.9392     10.2153
    6      0.9416     10.0029
    7      0.9400      9.9923
    8      0.9399      9.9435
    9      0.9388     10.1572
   10      0.9396     10.0224
   11      0.9401     10.0880
   12      0.9386      9.9075
   13      0.9393     10.1372
   14      0.9366     10.0808
   15      0.9404      9.9826
   16      0.9388     10.1187
   17      0.9414      9.9866
   18      0.9385     10.0141
   19      0.9392     10.0966
   20      0.9381     10.0430
   21      0.9396     10.0605
   22      0.9399     10.4051
   23      0.9383      9.9905
   24      0.9379     10.2293

====================================================================================================
TRAINING SCRIPT (code from log['code'])
====================================================================================================
# Taken from https://github.com/KellerJordan/cifar10-airbench/blob/master/legacy/airbench94.py
# Uncompiled variant of airbench94_compiled.py
# 3.83s runtime on an A100; 0.36 PFLOPs.
# Evidence: 94.01 average accuracy in n=1000 runs.
#
# We recorded the runtime of 3.83 seconds on an NVIDIA A100-SXM4-80GB with the following nvidia-smi:
# NVIDIA-SMI 515.105.01   Driver Version: 515.105.01   CUDA Version: 11.7
# torch.__version__ == '2.1.2+cu118'

#############################################
#            Setup/Hyperparameters          #
#############################################

import os
import sys
import uuid
from math import ceil

import torch
from torch import nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as T
import datetime


torch.backends.cudnn.benchmark = True

USE_COMPILE = bool(int(os.environ.get("AIRBENCH_USE_COMPILE", "1")))
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# We express the main training hyperparameters (batch size, learning rate, momentum, and weight decay)
# in decoupled form, so that each one can be tuned independently. This accomplishes the following:
# * Assuming time-constant gradients, the average step size is decoupled from everything but the lr.
# * The size of the weight decay update is decoupled from everything but the wd.
# In constrast, normally when we increase the (Nesterov) momentum, this also scales up the step size
# proportionally to 1 + 1 / (1 - momentum), meaning we cannot change momentum without having to re-tune
# the learning rate. Similarly, normally when we increase the learning rate this also increases the size
# of the weight decay, requiring a proportional decrease in the wd to maintain the same decay strength.
#
# The practical impact is that hyperparameter tuning is faster, since this parametrization allows each
# one to be tuned independently. See https://myrtle.ai/learn/how-to-train-your-resnet-5-hyperparameters/.

hyp = {
    'opt': {
        'train_epochs': 9.9,
        'batch_size': 1024,
        'lr': 11.5,                 # learning rate per 1024 examples
        'momentum': 0.85,
        'weight_decay': 0.0153,     # weight decay per 1024 examples (decoupled from learning rate)
        'bias_scaler': 64.0,        # scales up learning rate (but not weight decay) for BatchNorm biases
        'label_smoothing': 0.2,
        'whiten_bias_epochs': 3,    # how many epochs to train the whitening layer bias before freezing
    },
    'aug': {
        'flip': True,
        'translate': 2,
    },
    'net': {
        'widths': {
            'block1': 64,
            'block2': 256,
            'block3': 256,
        },
        'batchnorm_momentum': 0.6,
        'scaling_factor': 1/9,
        'tta_level': 2,         # the level of test-time augmentation: 0=none, 1=mirror, 2=mirror+translate
    },
}

#############################################
#                DataLoader                 #
#############################################

CIFAR_MEAN = torch.tensor((0.4914, 0.4822, 0.4465))
CIFAR_STD = torch.tensor((0.2470, 0.2435, 0.2616))

def batch_flip_lr(inputs):
    flip_mask = (torch.rand(len(inputs), device=inputs.device) < 0.5).view(-1, 1, 1, 1)
    return torch.where(flip_mask, inputs.flip(-1), inputs)

def random_translate(inputs, pad):
    if pad <= 0:
        return inputs
    inputs = inputs.contiguous()
    n, c, h, w = inputs.shape
    padded = F.pad(inputs, (pad, pad, pad, pad), mode="reflect")
    ys = torch.randint(-pad, pad + 1, (n,), device=inputs.device)
    xs = torch.randint(-pad, pad + 1, (n,), device=inputs.device)
    y_base = torch.arange(h, device=inputs.device).view(1, h, 1) + pad
    x_base = torch.arange(w, device=inputs.device).view(1, 1, w) + pad
    y_idx = (y_base + ys.view(n, 1, 1)).clamp(0, h + 2*pad - 1)
    x_idx = (x_base + xs.view(n, 1, 1)).clamp(0, w + 2*pad - 1)
    out = padded[
        torch.arange(n, device=inputs.device).view(n, 1, 1, 1),
        torch.arange(c, device=inputs.device).view(1, c, 1, 1),
        y_idx.view(n, 1, h, 1),
        x_idx.view(n, 1, 1, w)
    ]
    out = out.contiguous(memory_format=torch.channels_last)
    return out


class CifarLoader:

    def __init__(self, path, train=True, batch_size=500, aug=None, drop_last=None, shuffle=None, gpu=0):
        
        data_path = os.path.join(path, 'train.pt' if train else 'test.pt')
        if not os.path.exists(data_path):
            dset = torchvision.datasets.CIFAR10(path, download=True, train=train)
            images = torch.tensor(dset.data)
            labels = torch.tensor(dset.targets)
            torch.save({'images': images, 'labels': labels, 'classes': dset.classes}, data_path)
        # change here 
        # data = torch.load(data_path, map_location=torch.device(gpu))
        data = torch.load(data_path, map_location='cpu')
        images, labels, classes = data['images'], data['labels'], data['classes']
        images = images.permute(0, 3, 1, 2).contiguous()
        images = images.float().div_(255.0)
        normalize = T.Normalize(CIFAR_MEAN, CIFAR_STD)
        images = normalize(images)
        images = images.half().cuda(non_blocking=True)
        self.images = images.to(memory_format=torch.channels_last)
        self.labels = labels.long().cuda(non_blocking=True)
        self.classes = classes
        self.device = DEVICE

        self.aug = aug or {}
        for k in self.aug.keys():
            assert k in ['flip', 'translate'], f'Unrecognized key: {k}'

        self.batch_size = batch_size
        self.drop_last = train if drop_last is None else drop_last
        self.shuffle = train if shuffle is None else shuffle



    def __len__(self):
        n = len(self.images)
        if self.drop_last:
            return n // self.batch_size
        else:
            return ceil(n / self.batch_size)
    
    def __iter__(self):
        n = len(self.images)
        if self.shuffle:
            indices = torch.randperm(n, device=self.device)
        else:
            indices = torch.arange(n, device=self.device)

        for i in range(len(self)):
            idxs = indices[i * self.batch_size:(i + 1) * self.batch_size]
            batch_x = self.images[idxs]
            batch_y = self.labels[idxs]
            yield batch_x, batch_y

            

#############################################
#            Network Components             #
#############################################

class Flatten(nn.Module):
    def forward(self, x):
        return x.view(x.size(0), -1)

class Mul(nn.Module):
    def __init__(self, scale):
        super().__init__()
        self.scale = scale
    def forward(self, x):
        return x * self.scale

class BatchNorm(nn.BatchNorm2d):
    def __init__(self, num_features, momentum, eps=1e-12,
                 weight=False, bias=True):
        super().__init__(num_features, eps=eps, momentum=1-momentum)
        self.weight.requires_grad = weight
        self.bias.requires_grad = bias
        # Note that PyTorch already initializes the weights to one and bias to zero

class Conv(nn.Conv2d):
    def __init__(self, in_channels, out_channels, kernel_size=3, padding='same', bias=False):
        super().__init__(in_channels, out_channels, kernel_size=kernel_size, padding=padding, bias=bias)

    def reset_parameters(self):
        super().reset_parameters()
        if self.bias is not None:
            self.bias.data.zero_()
        w = self.weight.data
        torch.nn.init.dirac_(w[:w.size(1)])

class ConvGroup(nn.Module):
    def __init__(self, channels_in, channels_out, batchnorm_momentum):
        super().__init__()
        self.conv1 = Conv(channels_in,  channels_out)
        self.pool = nn.MaxPool2d(2)
        self.norm1 = BatchNorm(channels_out, batchnorm_momentum)
        self.conv2 = Conv(channels_out, channels_out)
        self.norm2 = BatchNorm(channels_out, batchnorm_momentum)
        self.activ = nn.GELU()

    def forward(self, x):
        x = self.conv1(x)
        x = self.pool(x)
        x = self.norm1(x)
        x = self.activ(x)
        x = self.conv2(x)
        x = self.norm2(x)
        x = self.activ(x)
        return x

#############################################
#            Network Definition             #
#############################################

def make_net():
    widths = hyp['net']['widths']
    batchnorm_momentum = hyp['net']['batchnorm_momentum']
    whiten_kernel_size = 2
    whiten_width = 2 * 3 * whiten_kernel_size**2
    net = nn.Sequential(
        Conv(3, whiten_width, whiten_kernel_size, padding=0, bias=True),
        nn.GELU(),
        ConvGroup(whiten_width,     widths['block1'], batchnorm_momentum),
        ConvGroup(widths['block1'], widths['block2'], batchnorm_momentum),
        ConvGroup(widths['block2'], widths['block3'], batchnorm_momentum),
        nn.MaxPool2d(3),
        Flatten(),
        nn.Linear(widths['block3'], 10, bias=False),
        Mul(hyp['net']['scaling_factor']),
    )
    net[0].weight.requires_grad = False
    net = net.half().cuda()
    net = net.to(memory_format=torch.channels_last)
    for mod in net.modules():
        if isinstance(mod, BatchNorm):
            mod.float()
    return net

#############################################
#       Whitening Conv Initialization       #
#############################################

def get_patches(x, patch_shape):
    c, (h, w) = x.shape[1], patch_shape
    return x.unfold(2,h,1).unfold(3,w,1).transpose(1,3).reshape(-1,c,h,w).float()

def get_whitening_parameters(patches):
    n,c,h,w = patches.shape
    patches_flat = patches.view(n, -1)
    est_patch_covariance = (patches_flat.T @ patches_flat) / n
    eigenvalues, eigenvectors = torch.linalg.eigh(est_patch_covariance, UPLO='U')
    return eigenvalues.flip(0).view(-1, 1, 1, 1), eigenvectors.T.reshape(c*h*w,c,h,w).flip(0)

def init_whitening_conv(layer, train_set, eps=5e-4):
    patches = get_patches(train_set, patch_shape=layer.weight.data.shape[2:])
    eigenvalues, eigenvectors = get_whitening_parameters(patches)
    eigenvectors_scaled = eigenvectors / torch.sqrt(eigenvalues + eps)
    layer.weight.data[:] = torch.cat((eigenvectors_scaled, -eigenvectors_scaled))

############################################
#                Lookahead                 #
############################################

class LookaheadState:
    def __init__(self, net):
        self.net_ema = {k: v.clone() for k, v in net.state_dict().items()}

    def update(self, net, decay):
        for ema_param, net_param in zip(self.net_ema.values(), net.state_dict().values()):
            if net_param.dtype in (torch.half, torch.float):
                ema_param.lerp_(net_param, 1-decay)
                net_param.copy_(ema_param)

############################################
#                 Logging                  #
############################################

def print_columns(columns_list, is_head=False, is_final_entry=False):
    print_string = ''
    for col in columns_list:
        print_string += '|  %s  ' % col
    print_string += '|'
    if is_head:
        print('-'*len(print_string))
    print(print_string)
    if is_head or is_final_entry:
        print('-'*len(print_string))

logging_columns_list = ['run   ', 'epoch', 'train_loss', 'train_acc', 'val_acc', 'tta_val_acc', 'total_time_seconds', 'timestamp']
def print_training_details(variables, is_final_entry):
    formatted = []
    variables['timestamp'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    for col in logging_columns_list:
        var = variables.get(col.strip(), None)
        if type(var) in (int, str):
            res = str(var)
        elif type(var) is float:
            res = '{:0.4f}'.format(var)
        else:
            assert var is None
            res = ''
        formatted.append(res.rjust(len(col)))
    print_columns(formatted, is_final_entry=is_final_entry)

############################################
#               Evaluation                 #
############################################

def infer(model, loader, tta_level=0):

    # Test-time augmentation strategy (for tta_level=2):
    # 1. Flip/mirror the image left-to-right (50% of the time).
    # 2. Translate the image by one pixel either up-and-left or down-and-right (50% of the time,
    #    i.e. both happen 25% of the time).
    #
    # This creates 6 views per image (left/right times the two translations and no-translation),
    # which we evaluate and then weight according to the given probabilities.

    def infer_basic(inputs, net):
        return net(inputs).clone()

    def infer_mirror(inputs, net):
        return 0.5 * net(inputs) + 0.5 * net(inputs.flip(-1))

    def infer_mirror_translate(inputs, net):
        logits = infer_mirror(inputs, net)
        pad = 1
        padded_inputs = F.pad(inputs, (pad,)*4, 'reflect')
        inputs_translate_list = [
            padded_inputs[:, :, 0:32, 0:32],
            padded_inputs[:, :, 2:34, 2:34],
        ]
        logits_translate_list = [infer_mirror(inputs_translate, net)
                                 for inputs_translate in inputs_translate_list]
        logits_translate = torch.stack(logits_translate_list).mean(0)
        return 0.5 * logits + 0.5 * logits_translate

    model.eval()
    #change
    # test_images = loader.normalize(loader.images)
    test_images = loader.images
    #end change
    infer_fn = [infer_basic, infer_mirror, infer_mirror_translate][tta_level]
    with torch.no_grad():
        return torch.cat([infer_fn(inputs, model) for inputs in test_images.split(2000)])

def evaluate(model, loader, tta_level=0):
    logits = infer(model, loader, tta_level)
    #change
    # return (logits.argmax(1) == loader.labels).float().mean().item()
    labels = loader.labels
    return (logits.argmax(1) == labels).float().mean().item()
#end change


############################################
#                Training                  #
############################################

def main(run):

    batch_size = hyp['opt']['batch_size']
    epochs = hyp['opt']['train_epochs']
    momentum = hyp['opt']['momentum']
    # Assuming gradients are constant in time, for Nesterov momentum, the below ratio is how much
    # larger the default steps will be than the underlying per-example gradients. We divide the
    # learning rate by this ratio in order to ensure steps are the same scale as gradients, regardless
    # of the choice of momentum.
    kilostep_scale = 1024 * (1 + 1 / (1 - momentum))
    lr = hyp['opt']['lr'] / kilostep_scale # un-decoupled learning rate for PyTorch SGD
    wd = hyp['opt']['weight_decay'] * batch_size / kilostep_scale
    lr_biases = lr * hyp['opt']['bias_scaler']

    loss_fn = nn.CrossEntropyLoss(label_smoothing=hyp['opt']['label_smoothing'], reduction='none')
    test_loader = CifarLoader('cifar10', train=False, batch_size=2000)
    train_loader = CifarLoader('cifar10', train=True, batch_size=batch_size, aug=hyp['aug'])
    if run == 'warmup':
        # The only purpose of the first run is to warmup, so we can use dummy data
        train_loader.labels = torch.randint(0, 10, size=(len(train_loader.labels),), device=train_loader.labels.device)
    total_train_steps = ceil(len(train_loader) * epochs)
    model = make_net()
    current_steps = 0

    norm_biases = [p for k, p in model.named_parameters() if 'norm' in k and p.requires_grad]
    other_params = [p for k, p in model.named_parameters() if 'norm' not in k and p.requires_grad]
    param_configs = [dict(params=norm_biases, lr=lr_biases, weight_decay=wd/lr_biases),
                     dict(params=other_params, lr=lr, weight_decay=wd/lr)]
    optimizer = torch.optim.SGD(param_configs, momentum=momentum, nesterov=True)

    def get_lr(step):
        warmup_steps = int(total_train_steps * 0.23)
        warmdown_steps = total_train_steps - warmup_steps
        if step < warmup_steps:
            frac = step / warmup_steps
            return 0.2 * (1 - frac) + 1.0 * frac
        else:
            frac = (step - warmup_steps) / warmdown_steps
            return 1.0 * (1 - frac) + 0.07 * frac
    scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, get_lr)

    alpha_schedule = 0.95**5 * (torch.arange(total_train_steps+1) / total_train_steps)**3
    lookahead_state = LookaheadState(model)

    # For accurately timing GPU code
    starter = torch.cuda.Event(enable_timing=True)
    ender = torch.cuda.Event(enable_timing=True)
    total_time_seconds = 0.0

    # Initialize the whitening layer using training images
    starter.record()
    #change
    # train_images = train_loader.normalize(train_loader.images[:5000])
    raw_data = torch.load('cifar10/train.pt', map_location='cpu')
    raw_images = raw_data['images'][:5000]
    raw_images = raw_images.float() / 255.0
    raw_images = raw_images.permute(0, 3, 1, 2)
    init_whitening_conv(model[0], raw_images)

#end change
    ender.record()
    torch.cuda.synchronize()
    total_time_seconds += 1e-3 * starter.elapsed_time(ender)
    #change add in
    # model = torch.compile(model, mode="reduce-overhead", backend="inductor")
    # for m in model.modules():
    #     if isinstance(m, BatchNorm):
    #         m.float()
    #         m.eval()
    #end change

    for epoch in range(ceil(epochs)):

        model[0].bias.requires_grad = (epoch < hyp['opt']['whiten_bias_epochs'])

        ####################
        #     Training     #
        ####################

        starter.record()

        model.train()
        for inputs, labels in train_loader:
            #change 
            #onc memory is pinned it overlaps cpu to gpu transfer 
            # outputs = model(inputs)
            if train_loader.aug.get('flip', False):
                inputs = batch_flip_lr(inputs)
            pad = train_loader.aug.get('translate', 0)
            if pad > 0:
                inputs = random_translate(inputs, pad)
            inputs = inputs.contiguous()
            inputs = inputs.to(memory_format=torch.channels_last)
            assert inputs.shape[1] == 3, f"BAD SHAPE: {inputs.shape}"
            outputs = model(inputs)
            # end change
            loss = loss_fn(outputs, labels).sum()
            optimizer.zero_grad(set_to_none=True)
            loss.backward()
            optimizer.step()
            scheduler.step()

            current_steps += 1

            if current_steps % 5 == 0:
                lookahead_state.update(model, decay=alpha_schedule[current_steps].item())

            if current_steps >= total_train_steps:
                if lookahead_state is not None:
                    lookahead_state.update(model, decay=1.0)
                break

        ender.record()
        torch.cuda.synchronize()
        total_time_seconds += 1e-3 * starter.elapsed_time(ender)


        ####################
        #    Evaluation    #
        ####################

        # Save the accuracy and loss from the last training batch of the epoch
        train_acc = (outputs.detach().argmax(1) == labels).float().mean().item()
        train_loss = loss.item() / batch_size
        val_acc = evaluate(model, test_loader, tta_level=0)
        print_training_details(locals(), is_final_entry=False)
        run = None # Only print the run number once

    ####################
    #  TTA Evaluation  #
    ####################

    starter.record()
    tta_val_acc = evaluate(model, test_loader, tta_level=hyp['net']['tta_level'])
    ender.record()
    torch.cuda.synchronize()
    total_time_seconds += 1e-3 * starter.elapsed_time(ender)

    epoch = 'eval'
    print_training_details(locals(), is_final_entry=True)

    return tta_val_acc

if __name__ == "__main__":
    with open(sys.argv[0]) as f:
        code = f.read()

    print_columns(logging_columns_list, is_head=True)
    #main('warmup')
    start_time = datetime.datetime.now()
    print(f"Starting 25 runs at: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    accs_list = []
    times_list = []
    for run in range(25):
        run_start = datetime.datetime.now()
        acc = main(run)
        run_end = datetime.datetime.now()
        accs_list.append(acc)
        times_list.append((run_end - run_start).total_seconds())
    accs = torch.tensor(accs_list)
    times = torch.tensor(times_list)
    mean_time = times.mean().item()

    end_time = datetime.datetime.now()
    elapsed = end_time - start_time
    print('Mean: %.4f    Std: %.4f' % (accs.mean(), accs.std()))
    log = {
    'code': code,
    'accs': accs,
    'times': times,
    'mean_time': mean_time,
    'created_at': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
}
    log_dir = os.path.join('logs', str(uuid.uuid4()))
    os.makedirs(log_dir, exist_ok=True)
    log_path = os.path.join(log_dir, 'log.pt')
    print(os.path.abspath(log_path))
    torch.save(log, os.path.join(log_dir, 'log.pt'))



====================================================================================================
RAW LOG DICTIONARY DUMP
====================================================================================================

{ 'accs': tensor([0.9393, 0.9383, 0.9388, 0.9377, 0.9399, 0.9392, 0.9416, 0.9400, 0.9399,
        0.9388, 0.9396, 0.9401, 0.9386, 0.9393, 0.9366, 0.9404, 0.9388, 0.9414,
        0.9385, 0.9392, 0.9381, 0.9396, 0.9399, 0.9383, 0.9379]),
  'code': '# Taken from '
          'https://github.com/KellerJordan/cifar10-airbench/blob/master/legacy/airbench94.py\n'
          '# Uncompiled variant of airbench94_compiled.py\n'
          '# 3.83s runtime on an A100; 0.36 PFLOPs.\n'
          '# Evidence: 94.01 average accuracy in n=1000 runs.\n'
          '#\n'
          '# We recorded the runtime of 3.83 seconds on an NVIDIA A100-SXM4-80GB with the '
          'following nvidia-smi:\n'
          '# NVIDIA-SMI 515.105.01   Driver Version: 515.105.01   CUDA Version: 11.7\n'
          "# torch.__version__ == '2.1.2+cu118'\n"
          '\n'
          '#############################################\n'
          '#            Setup/Hyperparameters          #\n'
          '#############################################\n'
          '\n'
          'import os\n'
          'import sys\n'
          'import uuid\n'
          'from math import ceil\n'
          '\n'
          'import torch\n'
          'from torch import nn\n'
          'import torch.nn.functional as F\n'
          'import torchvision\n'
          'import torchvision.transforms as T\n'
          'import datetime\n'
          '\n'
          '\n'
          'torch.backends.cudnn.benchmark = True\n'
          '\n'
          'USE_COMPILE = bool(int(os.environ.get("AIRBENCH_USE_COMPILE", "1")))\n'
          'DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")\n'
          '\n'
          '# We express the main training hyperparameters (batch size, learning rate, momentum, '
          'and weight decay)\n'
          '# in decoupled form, so that each one can be tuned independently. This accomplishes the '
          'following:\n'
          '# * Assuming time-constant gradients, the average step size is decoupled from '
          'everything but the lr.\n'
          '# * The size of the weight decay update is decoupled from everything but the wd.\n'
          '# In constrast, normally when we increase the (Nesterov) momentum, this also scales up '
          'the step size\n'
          '# proportionally to 1 + 1 / (1 - momentum), meaning we cannot change momentum without '
          'having to re-tune\n'
          '# the learning rate. Similarly, normally when we increase the learning rate this also '
          'increases the size\n'
          '# of the weight decay, requiring a proportional decrease in the wd to maintain the same '
          'decay strength.\n'
          '#\n'
          '# The practical impact is that hyperparameter tuning is faster, since this '
          'parametrization allows each\n'
          '# one to be tuned independently. See '
          'https://myrtle.ai/learn/how-to-train-your-resnet-5-hyperparameters/.\n'
          '\n'
          'hyp = {\n'
          "    'opt': {\n"
          "        'train_epochs': 9.9,\n"
          "        'batch_size': 1024,\n"
          "        'lr': 11.5,                 # learning rate per 1024 examples\n"
          "        'momentum': 0.85,\n"
          "        'weight_decay': 0.0153,     # weight decay per 1024 examples (decoupled from "
          'learning rate)\n'
          "        'bias_scaler': 64.0,        # scales up learning rate (but not weight decay) "
          'for BatchNorm biases\n'
          "        'label_smoothing': 0.2,\n"
          "        'whiten_bias_epochs': 3,    # how many epochs to train the whitening layer bias "
          'before freezing\n'
          '    },\n'
          "    'aug': {\n"
          "        'flip': True,\n"
          "        'translate': 2,\n"
          '    },\n'
          "    'net': {\n"
          "        'widths': {\n"
          "            'block1': 64,\n"
          "            'block2': 256,\n"
          "            'block3': 256,\n"
          '        },\n'
          "        'batchnorm_momentum': 0.6,\n"
          "        'scaling_factor': 1/9,\n"
          "        'tta_level': 2,         # the level of test-time augmentation: 0=none, "
          '1=mirror, 2=mirror+translate\n'
          '    },\n'
          '}\n'
          '\n'
          '#############################################\n'
          '#                DataLoader                 #\n'
          '#############################################\n'
          '\n'
          'CIFAR_MEAN = torch.tensor((0.4914, 0.4822, 0.4465))\n'
          'CIFAR_STD = torch.tensor((0.2470, 0.2435, 0.2616))\n'
          '\n'
          'def batch_flip_lr(inputs):\n'
          '    flip_mask = (torch.rand(len(inputs), device=inputs.device) < 0.5).view(-1, 1, 1, '
          '1)\n'
          '    return torch.where(flip_mask, inputs.flip(-1), inputs)\n'
          '\n'
          'def random_translate(inputs, pad):\n'
          '    if pad <= 0:\n'
          '        return inputs\n'
          '    inputs = inputs.contiguous()\n'
          '    n, c, h, w = inputs.shape\n'
          '    padded = F.pad(inputs, (pad, pad, pad, pad), mode="reflect")\n'
          '    ys = torch.randint(-pad, pad + 1, (n,), device=inputs.device)\n'
          '    xs = torch.randint(-pad, pad + 1, (n,), device=inputs.device)\n'
          '    y_base = torch.arange(h, device=inputs.device).view(1, h, 1) + pad\n'
          '    x_base = torch.arange(w, device=inputs.device).view(1, 1, w) + pad\n'
          '    y_idx = (y_base + ys.view(n, 1, 1)).clamp(0, h + 2*pad - 1)\n'
          '    x_idx = (x_base + xs.view(n, 1, 1)).clamp(0, w + 2*pad - 1)\n'
          '    out = padded[\n'
          '        torch.arange(n, device=inputs.device).view(n, 1, 1, 1),\n'
          '        torch.arange(c, device=inputs.device).view(1, c, 1, 1),\n'
          '        y_idx.view(n, 1, h, 1),\n'
          '        x_idx.view(n, 1, 1, w)\n'
          '    ]\n'
          '    out = out.contiguous(memory_format=torch.channels_last)\n'
          '    return out\n'
          '\n'
          '\n'
          'class CifarLoader:\n'
          '\n'
          '    def __init__(self, path, train=True, batch_size=500, aug=None, drop_last=None, '
          'shuffle=None, gpu=0):\n'
          '        \n'
          "        data_path = os.path.join(path, 'train.pt' if train else 'test.pt')\n"
          '        if not os.path.exists(data_path):\n'
          '            dset = torchvision.datasets.CIFAR10(path, download=True, train=train)\n'
          '            images = torch.tensor(dset.data)\n'
          '            labels = torch.tensor(dset.targets)\n'
          "            torch.save({'images': images, 'labels': labels, 'classes': dset.classes}, "
          'data_path)\n'
          '        # change here \n'
          '        # data = torch.load(data_path, map_location=torch.device(gpu))\n'
          "        data = torch.load(data_path, map_location='cpu')\n"
          "        images, labels, classes = data['images'], data['labels'], data['classes']\n"
          '        images = images.permute(0, 3, 1, 2).contiguous()\n'
          '        images = images.float().div_(255.0)\n'
          '        normalize = T.Normalize(CIFAR_MEAN, CIFAR_STD)\n'
          '        images = normalize(images)\n'
          '        images = images.half().cuda(non_blocking=True)\n'
          '        self.images = images.to(memory_format=torch.channels_last)\n'
          '        self.labels = labels.long().cuda(non_blocking=True)\n'
          '        self.classes = classes\n'
          '        self.device = DEVICE\n'
          '\n'
          '        self.aug = aug or {}\n'
          '        for k in self.aug.keys():\n'
          "            assert k in ['flip', 'translate'], f'Unrecognized key: {k}'\n"
          '\n'
          '        self.batch_size = batch_size\n'
          '        self.drop_last = train if drop_last is None else drop_last\n'
          '        self.shuffle = train if shuffle is None else shuffle\n'
          '\n'
          '\n'
          '\n'
          '    def __len__(self):\n'
          '        n = len(self.images)\n'
          '        if self.drop_last:\n'
          '            return n // self.batch_size\n'
          '        else:\n'
          '            return ceil(n / self.batch_size)\n'
          '    \n'
          '    def __iter__(self):\n'
          '        n = len(self.images)\n'
          '        if self.shuffle:\n'
          '            indices = torch.randperm(n, device=self.device)\n'
          '        else:\n'
          '            indices = torch.arange(n, device=self.device)\n'
          '\n'
          '        for i in range(len(self)):\n'
          '            idxs = indices[i * self.batch_size:(i + 1) * self.batch_size]\n'
          '            batch_x = self.images[idxs]\n'
          '            batch_y = self.labels[idxs]\n'
          '            yield batch_x, batch_y\n'
          '\n'
          '            \n'
          '\n'
          '#############################################\n'
          '#            Network Components             #\n'
          '#############################################\n'
          '\n'
          'class Flatten(nn.Module):\n'
          '    def forward(self, x):\n'
          '        return x.view(x.size(0), -1)\n'
          '\n'
          'class Mul(nn.Module):\n'
          '    def __init__(self, scale):\n'
          '        super().__init__()\n'
          '        self.scale = scale\n'
          '    def forward(self, x):\n'
          '        return x * self.scale\n'
          '\n'
          'class BatchNorm(nn.BatchNorm2d):\n'
          '    def __init__(self, num_features, momentum, eps=1e-12,\n'
          '                 weight=False, bias=True):\n'
          '        super().__init__(num_features, eps=eps, momentum=1-momentum)\n'
          '        self.weight.requires_grad = weight\n'
          '        self.bias.requires_grad = bias\n'
          '        # Note that PyTorch already initializes the weights to one and bias to zero\n'
          '\n'
          'class Conv(nn.Conv2d):\n'
          "    def __init__(self, in_channels, out_channels, kernel_size=3, padding='same', "
          'bias=False):\n'
          '        super().__init__(in_channels, out_channels, kernel_size=kernel_size, '
          'padding=padding, bias=bias)\n'
          '\n'
          '    def reset_parameters(self):\n'
          '        super().reset_parameters()\n'
          '        if self.bias is not None:\n'
          '            self.bias.data.zero_()\n'
          '        w = self.weight.data\n'
          '        torch.nn.init.dirac_(w[:w.size(1)])\n'
          '\n'
          'class ConvGroup(nn.Module):\n'
          '    def __init__(self, channels_in, channels_out, batchnorm_momentum):\n'
          '        super().__init__()\n'
          '        self.conv1 = Conv(channels_in,  channels_out)\n'
          '        self.pool = nn.MaxPool2d(2)\n'
          '        self.norm1 = BatchNorm(channels_out, batchnorm_momentum)\n'
          '        self.conv2 = Conv(channels_out, channels_out)\n'
          '        self.norm2 = BatchNorm(channels_out, batchnorm_momentum)\n'
          '        self.activ = nn.GELU()\n'
          '\n'
          '    def forward(self, x):\n'
          '        x = self.conv1(x)\n'
          '        x = self.pool(x)\n'
          '        x = self.norm1(x)\n'
          '        x = self.activ(x)\n'
          '        x = self.conv2(x)\n'
          '        x = self.norm2(x)\n'
          '        x = self.activ(x)\n'
          '        return x\n'
          '\n'
          '#############################################\n'
          '#            Network Definition             #\n'
          '#############################################\n'
          '\n'
          'def make_net():\n'
          "    widths = hyp['net']['widths']\n"
          "    batchnorm_momentum = hyp['net']['batchnorm_momentum']\n"
          '    whiten_kernel_size = 2\n'
          '    whiten_width = 2 * 3 * whiten_kernel_size**2\n'
          '    net = nn.Sequential(\n'
          '        Conv(3, whiten_width, whiten_kernel_size, padding=0, bias=True),\n'
          '        nn.GELU(),\n'
          "        ConvGroup(whiten_width,     widths['block1'], batchnorm_momentum),\n"
          "        ConvGroup(widths['block1'], widths['block2'], batchnorm_momentum),\n"
          "        ConvGroup(widths['block2'], widths['block3'], batchnorm_momentum),\n"
          '        nn.MaxPool2d(3),\n'
          '        Flatten(),\n'
          "        nn.Linear(widths['block3'], 10, bias=False),\n"
          "        Mul(hyp['net']['scaling_factor']),\n"
          '    )\n'
          '    net[0].weight.requires_grad = False\n'
          '    net = net.half().cuda()\n'
          '    net = net.to(memory_format=torch.channels_last)\n'
          '    for mod in net.modules():\n'
          '        if isinstance(mod, BatchNorm):\n'
          '            mod.float()\n'
          '    return net\n'
          '\n'
          '#############################################\n'
          '#       Whitening Conv Initialization       #\n'
          '#############################################\n'
          '\n'
          'def get_patches(x, patch_shape):\n'
          '    c, (h, w) = x.shape[1], patch_shape\n'
          '    return x.unfold(2,h,1).unfold(3,w,1).transpose(1,3).reshape(-1,c,h,w).float()\n'
          '\n'
          'def get_whitening_parameters(patches):\n'
          '    n,c,h,w = patches.shape\n'
          '    patches_flat = patches.view(n, -1)\n'
          '    est_patch_covariance = (patches_flat.T @ patches_flat) / n\n'
          "    eigenvalues, eigenvectors = torch.linalg.eigh(est_patch_covariance, UPLO='U')\n"
          '    return eigenvalues.flip(0).view(-1, 1, 1, 1), '
          'eigenvectors.T.reshape(c*h*w,c,h,w).flip(0)\n'
          '\n'
          'def init_whitening_conv(layer, train_set, eps=5e-4):\n'
          '    patches = get_patches(train_set, patch_shape=layer.weight.data.shape[2:])\n'
          '    eigenvalues, eigenvectors = get_whitening_parameters(patches)\n'
          '    eigenvectors_scaled = eigenvectors / torch.sqrt(eigenvalues + eps)\n'
          '    layer.weight.data[:] = torch.cat((eigenvectors_scaled, -eigenvectors_scaled))\n'
          '\n'
          '############################################\n'
          '#                Lookahead                 #\n'
          '############################################\n'
          '\n'
          'class LookaheadState:\n'
          '    def __init__(self, net):\n'
          '        self.net_ema = {k: v.clone() for k, v in net.state_dict().items()}\n'
          '\n'
          '    def update(self, net, decay):\n'
          '        for ema_param, net_param in zip(self.net_ema.values(), '
          'net.state_dict().values()):\n'
          '            if net_param.dtype in (torch.half, torch.float):\n'
          '                ema_param.lerp_(net_param, 1-decay)\n'
          '                net_param.copy_(ema_param)\n'
          '\n'
          '############################################\n'
          '#                 Logging                  #\n'
          '############################################\n'
          '\n'
          'def print_columns(columns_list, is_head=False, is_final_entry=False):\n'
          "    print_string = ''\n"
          '    for col in columns_list:\n'
          "        print_string += '|  %s  ' % col\n"
          "    print_string += '|'\n"
          '    if is_head:\n'
          "        print('-'*len(print_string))\n"
          '    print(print_string)\n'
          '    if is_head or is_final_entry:\n'
          "        print('-'*len(print_string))\n"
          '\n'
          "logging_columns_list = ['run   ', 'epoch', 'train_loss', 'train_acc', 'val_acc', "
          "'tta_val_acc', 'total_time_seconds', 'timestamp']\n"
          'def print_training_details(variables, is_final_entry):\n'
          '    formatted = []\n'
          '    variables[\'timestamp\'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\n'
          '    for col in logging_columns_list:\n'
          '        var = variables.get(col.strip(), None)\n'
          '        if type(var) in (int, str):\n'
          '            res = str(var)\n'
          '        elif type(var) is float:\n'
          "            res = '{:0.4f}'.format(var)\n"
          '        else:\n'
          '            assert var is None\n'
          "            res = ''\n"
          '        formatted.append(res.rjust(len(col)))\n'
          '    print_columns(formatted, is_final_entry=is_final_entry)\n'
          '\n'
          '############################################\n'
          '#               Evaluation                 #\n'
          '############################################\n'
          '\n'
          'def infer(model, loader, tta_level=0):\n'
          '\n'
          '    # Test-time augmentation strategy (for tta_level=2):\n'
          '    # 1. Flip/mirror the image left-to-right (50% of the time).\n'
          '    # 2. Translate the image by one pixel either up-and-left or down-and-right (50% of '
          'the time,\n'
          '    #    i.e. both happen 25% of the time).\n'
          '    #\n'
          '    # This creates 6 views per image (left/right times the two translations and '
          'no-translation),\n'
          '    # which we evaluate and then weight according to the given probabilities.\n'
          '\n'
          '    def infer_basic(inputs, net):\n'
          '        return net(inputs).clone()\n'
          '\n'
          '    def infer_mirror(inputs, net):\n'
          '        return 0.5 * net(inputs) + 0.5 * net(inputs.flip(-1))\n'
          '\n'
          '    def infer_mirror_translate(inputs, net):\n'
          '        logits = infer_mirror(inputs, net)\n'
          '        pad = 1\n'
          "        padded_inputs = F.pad(inputs, (pad,)*4, 'reflect')\n"
          '        inputs_translate_list = [\n'
          '            padded_inputs[:, :, 0:32, 0:32],\n'
          '            padded_inputs[:, :, 2:34, 2:34],\n'
          '        ]\n'
          '        logits_translate_list = [infer_mirror(inputs_translate, net)\n'
          '                                 for inputs_translate in inputs_translate_list]\n'
          '        logits_translate = torch.stack(logits_translate_list).mean(0)\n'
          '        return 0.5 * logits + 0.5 * logits_translate\n'
          '\n'
          '    model.eval()\n'
          '    #change\n'
          '    # test_images = loader.normalize(loader.images)\n'
          '    test_images = loader.images\n'
          '    #end change\n'
          '    infer_fn = [infer_basic, infer_mirror, infer_mirror_translate][tta_level]\n'
          '    with torch.no_grad():\n'
          '        return torch.cat([infer_fn(inputs, model) for inputs in '
          'test_images.split(2000)])\n'
          '\n'
          'def evaluate(model, loader, tta_level=0):\n'
          '    logits = infer(model, loader, tta_level)\n'
          '    #change\n'
          '    # return (logits.argmax(1) == loader.labels).float().mean().item()\n'
          '    labels = loader.labels\n'
          '    return (logits.argmax(1) == labels).float().mean().item()\n'
          '#end change\n'
          '\n'
          '\n'
          '############################################\n'
          '#                Training                  #\n'
          '############################################\n'
          '\n'
          'def main(run):\n'
          '\n'
          "    batch_size = hyp['opt']['batch_size']\n"
          "    epochs = hyp['opt']['train_epochs']\n"
          "    momentum = hyp['opt']['momentum']\n"
          '    # Assuming gradients are constant in time, for Nesterov momentum, the below ratio '
          'is how much\n'
          '    # larger the default steps will be than the underlying per-example gradients. We '
          'divide the\n'
          '    # learning rate by this ratio in order to ensure steps are the same scale as '
          'gradients, regardless\n'
          '    # of the choice of momentum.\n'
          '    kilostep_scale = 1024 * (1 + 1 / (1 - momentum))\n'
          "    lr = hyp['opt']['lr'] / kilostep_scale # un-decoupled learning rate for PyTorch "
          'SGD\n'
          "    wd = hyp['opt']['weight_decay'] * batch_size / kilostep_scale\n"
          "    lr_biases = lr * hyp['opt']['bias_scaler']\n"
          '\n'
          "    loss_fn = nn.CrossEntropyLoss(label_smoothing=hyp['opt']['label_smoothing'], "
          "reduction='none')\n"
          "    test_loader = CifarLoader('cifar10', train=False, batch_size=2000)\n"
          "    train_loader = CifarLoader('cifar10', train=True, batch_size=batch_size, "
          "aug=hyp['aug'])\n"
          "    if run == 'warmup':\n"
          '        # The only purpose of the first run is to warmup, so we can use dummy data\n'
          '        train_loader.labels = torch.randint(0, 10, size=(len(train_loader.labels),), '
          'device=train_loader.labels.device)\n'
          '    total_train_steps = ceil(len(train_loader) * epochs)\n'
          '    model = make_net()\n'
          '    current_steps = 0\n'
          '\n'
          "    norm_biases = [p for k, p in model.named_parameters() if 'norm' in k and "
          'p.requires_grad]\n'
          "    other_params = [p for k, p in model.named_parameters() if 'norm' not in k and "
          'p.requires_grad]\n'
          '    param_configs = [dict(params=norm_biases, lr=lr_biases, '
          'weight_decay=wd/lr_biases),\n'
          '                     dict(params=other_params, lr=lr, weight_decay=wd/lr)]\n'
          '    optimizer = torch.optim.SGD(param_configs, momentum=momentum, nesterov=True)\n'
          '\n'
          '    def get_lr(step):\n'
          '        warmup_steps = int(total_train_steps * 0.23)\n'
          '        warmdown_steps = total_train_steps - warmup_steps\n'
          '        if step < warmup_steps:\n'
          '            frac = step / warmup_steps\n'
          '            return 0.2 * (1 - frac) + 1.0 * frac\n'
          '        else:\n'
          '            frac = (step - warmup_steps) / warmdown_steps\n'
          '            return 1.0 * (1 - frac) + 0.07 * frac\n'
          '    scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, get_lr)\n'
          '\n'
          '    alpha_schedule = 0.95**5 * (torch.arange(total_train_steps+1) / '
          'total_train_steps)**3\n'
          '    lookahead_state = LookaheadState(model)\n'
          '\n'
          '    # For accurately timing GPU code\n'
          '    starter = torch.cuda.Event(enable_timing=True)\n'
          '    ender = torch.cuda.Event(enable_timing=True)\n'
          '    total_time_seconds = 0.0\n'
          '\n'
          '    # Initialize the whitening layer using training images\n'
          '    starter.record()\n'
          '    #change\n'
          '    # train_images = train_loader.normalize(train_loader.images[:5000])\n'
          "    raw_data = torch.load('cifar10/train.pt', map_location='cpu')\n"
          "    raw_images = raw_data['images'][:5000]\n"
          '    raw_images = raw_images.float() / 255.0\n'
          '    raw_images = raw_images.permute(0, 3, 1, 2)\n'
          '    init_whitening_conv(model[0], raw_images)\n'
          '\n'
          '#end change\n'
          '    ender.record()\n'
          '    torch.cuda.synchronize()\n'
          '    total_time_seconds += 1e-3 * starter.elapsed_time(ender)\n'
          '    #change add in\n'
          '    # model = torch.compile(model, mode="reduce-overhead", backend="inductor")\n'
          '    # for m in model.modules():\n'
          '    #     if isinstance(m, BatchNorm):\n'
          '    #         m.float()\n'
          '    #         m.eval()\n'
          '    #end change\n'
          '\n'
          '    for epoch in range(ceil(epochs)):\n'
          '\n'
          "        model[0].bias.requires_grad = (epoch < hyp['opt']['whiten_bias_epochs'])\n"
          '\n'
          '        ####################\n'
          '        #     Training     #\n'
          '        ####################\n'
          '\n'
          '        starter.record()\n'
          '\n'
          '        model.train()\n'
          '        for inputs, labels in train_loader:\n'
          '            #change \n'
          '            #onc memory is pinned it overlaps cpu to gpu transfer \n'
          '            # outputs = model(inputs)\n'
          "            if train_loader.aug.get('flip', False):\n"
          '                inputs = batch_flip_lr(inputs)\n'
          "            pad = train_loader.aug.get('translate', 0)\n"
          '            if pad > 0:\n'
          '                inputs = random_translate(inputs, pad)\n'
          '            inputs = inputs.contiguous()\n'
          '            inputs = inputs.to(memory_format=torch.channels_last)\n'
          '            assert inputs.shape[1] == 3, f"BAD SHAPE: {inputs.shape}"\n'
          '            outputs = model(inputs)\n'
          '            # end change\n'
          '            loss = loss_fn(outputs, labels).sum()\n'
          '            optimizer.zero_grad(set_to_none=True)\n'
          '            loss.backward()\n'
          '            optimizer.step()\n'
          '            scheduler.step()\n'
          '\n'
          '            current_steps += 1\n'
          '\n'
          '            if current_steps % 5 == 0:\n'
          '                lookahead_state.update(model, '
          'decay=alpha_schedule[current_steps].item())\n'
          '\n'
          '            if current_steps >= total_train_steps:\n'
          '                if lookahead_state is not None:\n'
          '                    lookahead_state.update(model, decay=1.0)\n'
          '                break\n'
          '\n'
          '        ender.record()\n'
          '        torch.cuda.synchronize()\n'
          '        total_time_seconds += 1e-3 * starter.elapsed_time(ender)\n'
          '\n'
          '\n'
          '        ####################\n'
          '        #    Evaluation    #\n'
          '        ####################\n'
          '\n'
          '        # Save the accuracy and loss from the last training batch of the epoch\n'
          '        train_acc = (outputs.detach().argmax(1) == labels).float().mean().item()\n'
          '        train_loss = loss.item() / batch_size\n'
          '        val_acc = evaluate(model, test_loader, tta_level=0)\n'
          '        print_training_details(locals(), is_final_entry=False)\n'
          '        run = None # Only print the run number once\n'
          '\n'
          '    ####################\n'
          '    #  TTA Evaluation  #\n'
          '    ####################\n'
          '\n'
          '    starter.record()\n'
          "    tta_val_acc = evaluate(model, test_loader, tta_level=hyp['net']['tta_level'])\n"
          '    ender.record()\n'
          '    torch.cuda.synchronize()\n'
          '    total_time_seconds += 1e-3 * starter.elapsed_time(ender)\n'
          '\n'
          "    epoch = 'eval'\n"
          '    print_training_details(locals(), is_final_entry=True)\n'
          '\n'
          '    return tta_val_acc\n'
          '\n'
          'if __name__ == "__main__":\n'
          '    with open(sys.argv[0]) as f:\n'
          '        code = f.read()\n'
          '\n'
          '    print_columns(logging_columns_list, is_head=True)\n'
          "    #main('warmup')\n"
          '    start_time = datetime.datetime.now()\n'
          '    print(f"Starting 25 runs at: {start_time.strftime(\'%Y-%m-%d %H:%M:%S\')}")\n'
          '    accs_list = []\n'
          '    times_list = []\n'
          '    for run in range(25):\n'
          '        run_start = datetime.datetime.now()\n'
          '        acc = main(run)\n'
          '        run_end = datetime.datetime.now()\n'
          '        accs_list.append(acc)\n'
          '        times_list.append((run_end - run_start).total_seconds())\n'
          '    accs = torch.tensor(accs_list)\n'
          '    times = torch.tensor(times_list)\n'
          '    mean_time = times.mean().item()\n'
          '\n'
          '    end_time = datetime.datetime.now()\n'
          '    elapsed = end_time - start_time\n'
          "    print('Mean: %.4f    Std: %.4f' % (accs.mean(), accs.std()))\n"
          '    log = {\n'
          "    'code': code,\n"
          "    'accs': accs,\n"
          "    'times': times,\n"
          "    'mean_time': mean_time,\n"
          '    \'created_at\': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\n'
          '}\n'
          "    log_dir = os.path.join('logs', str(uuid.uuid4()))\n"
          '    os.makedirs(log_dir, exist_ok=True)\n'
          "    log_path = os.path.join(log_dir, 'log.pt')\n"
          '    print(os.path.abspath(log_path))\n'
          "    torch.save(log, os.path.join(log_dir, 'log.pt'))\n"
          '\n',
  'created_at': '2025-11-29 06:34:28',
  'mean_time': 10.723716735839844,
  'times': tensor([26.4644, 10.2362,  9.6039, 10.3265,  9.9877, 10.2153, 10.0029,  9.9923,
         9.9435, 10.1572, 10.0224, 10.0880,  9.9075, 10.1372, 10.0808,  9.9826,
        10.1187,  9.9866, 10.0141, 10.0966, 10.0430, 10.0605, 10.4051,  9.9905,
        10.2293])}