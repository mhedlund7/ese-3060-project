====================================================================================================
Experiment mode: <unknown>
====================================================================================================

Accuracy statistics:
  Runs: 25
  Mean: 0.9403
  Std:  0.0011
  Min:  0.9384
  Max:  0.9426

Runtime statistics (seconds):
  Runs: 25
  Mean: 3.8834
  Std:  0.0389
  Min:  3.8111
  Max:  3.9841

Per-run results:
  Run    Accuracy    Time (s)
  ----   --------    --------
    0      0.9387      3.8940
    1      0.9424      3.8111
    2      0.9411      3.8195
    3      0.9414      3.8291
    4      0.9402      3.8392
    5      0.9391      3.9352
    6      0.9412      3.8502
    7      0.9389      3.8588
    8      0.9400      3.8613
    9      0.9426      3.8665
   10      0.9400      3.8698
   11      0.9397      3.8758
   12      0.9404      3.9625
   13      0.9394      3.8808
   14      0.9392      3.8841
   15      0.9402      3.8861
   16      0.9384      3.8888
   17      0.9419      3.8909
   18      0.9413      3.9841
   19      0.9398      3.8960
   20      0.9404      3.8953
   21      0.9414      3.9023
   22      0.9409      3.9026
   23      0.9389      3.9006
   24      0.9405      3.9017

====================================================================================================
TRAINING SCRIPT (code from log['code'])
====================================================================================================
# Taken from https://github.com/KellerJordan/cifar10-airbench/blob/master/legacy/airbench94.py
# Uncompiled variant of airbench94_compiled.py
# 3.83s runtime on an A100; 0.36 PFLOPs.
# Evidence: 94.01 average accuracy in n=1000 runs.
#
# We recorded the runtime of 3.83 seconds on an NVIDIA A100-SXM4-80GB with the following nvidia-smi:
# NVIDIA-SMI 515.105.01   Driver Version: 515.105.01   CUDA Version: 11.7
# torch.__version__ == '2.1.2+cu118'

#############################################
#            Setup/Hyperparameters          #
#############################################

import os
import sys
import uuid
from math import ceil

import torch
from torch import nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as T
from datetime import datetime

torch.backends.cudnn.benchmark = True



# Set whether to precompile model with (precompiled baseline should be 3.29 as opposed to 3.83):
# AIRBENCH_USE_COMPILE=0 python airbench94.py   uncompiled baseline
# AIRBENCH_USE_COMPILE=1 python airbench94.py   compiled baseline

# Or set for multiple runs with:
# export AIRBENCH_USE_COMPILE=1
# export AIRBENCH_USE_COMPILE=0

USE_COMPILE = bool(int(os.environ.get("AIRBENCH_USE_COMPILE", "0")))

# We express the main training hyperparameters (batch size, learning rate, momentum, and weight decay)
# in decoupled form, so that each one can be tuned independently. This accomplishes the following:
# * Assuming time-constant gradients, the average step size is decoupled from everything but the lr.
# * The size of the weight decay update is decoupled from everything but the wd.
# In constrast, normally when we increase the (Nesterov) momentum, this also scales up the step size
# proportionally to 1 + 1 / (1 - momentum), meaning we cannot change momentum without having to re-tune
# the learning rate. Similarly, normally when we increase the learning rate this also increases the size
# of the weight decay, requiring a proportional decrease in the wd to maintain the same decay strength.
#
# The practical impact is that hyperparameter tuning is faster, since this parametrization allows each
# one to be tuned independently. See https://myrtle.ai/learn/how-to-train-your-resnet-5-hyperparameters/.

hyp = {
    'opt': {
        'train_epochs': 9.9,
        'batch_size': 1024,
        'lr': 11.5,                 # learning rate per 1024 examples
        'momentum': 0.85,
        'weight_decay': 0.0153,     # weight decay per 1024 examples (decoupled from learning rate)
        'bias_scaler': 64.0,        # scales up learning rate (but not weight decay) for BatchNorm biases
        'label_smoothing': 0.2,
        'whiten_bias_epochs': 3,    # how many epochs to train the whitening layer bias before freezing
    },
    'aug': {
        'flip': True,
        'translate': 2,
    },
    'net': {
        'widths': {
            'block1': 64,
            'block2': 256,
            'block3': 256,
        },
        'batchnorm_momentum': 0.6,
        'scaling_factor': 1/9,
        'tta_level': 2,         # the level of test-time augmentation: 0=none, 1=mirror, 2=mirror+translate
    },
}

#############################################
#                DataLoader                 #
#############################################

CIFAR_MEAN = torch.tensor((0.4914, 0.4822, 0.4465))
CIFAR_STD = torch.tensor((0.2470, 0.2435, 0.2616))

def batch_flip_lr(inputs):
    flip_mask = (torch.rand(len(inputs), device=inputs.device) < 0.5).view(-1, 1, 1, 1)
    return torch.where(flip_mask, inputs.flip(-1), inputs)

def batch_crop(images, crop_size):
    r = (images.size(-1) - crop_size)//2
    shifts = torch.randint(-r, r+1, size=(len(images), 2), device=images.device)
    images_out = torch.empty((len(images), 3, crop_size, crop_size), device=images.device, dtype=images.dtype)
    # The two cropping methods in this if-else produce equivalent results, but the second is faster for r > 2.
    if r <= 2:
        for sy in range(-r, r+1):
            for sx in range(-r, r+1):
                mask = (shifts[:, 0] == sy) & (shifts[:, 1] == sx)
                images_out[mask] = images[mask, :, r+sy:r+sy+crop_size, r+sx:r+sx+crop_size]
    else:
        images_tmp = torch.empty((len(images), 3, crop_size, crop_size+2*r), device=images.device, dtype=images.dtype)
        for s in range(-r, r+1):
            mask = (shifts[:, 0] == s)
            images_tmp[mask] = images[mask, :, r+s:r+s+crop_size, :]
        for s in range(-r, r+1):
            mask = (shifts[:, 1] == s)
            images_out[mask] = images_tmp[mask, :, :, r+s:r+s+crop_size]
    return images_out

class CifarLoader:

    def __init__(self, path, train=True, batch_size=500, aug=None, drop_last=None, shuffle=None, gpu=0):
        data_path = os.path.join(path, 'train.pt' if train else 'test.pt')
        if not os.path.exists(data_path):
            dset = torchvision.datasets.CIFAR10(path, download=True, train=train)
            images = torch.tensor(dset.data)
            labels = torch.tensor(dset.targets)
            torch.save({'images': images, 'labels': labels, 'classes': dset.classes}, data_path)

        data = torch.load(data_path, map_location=torch.device(gpu))
        self.images, self.labels, self.classes = data['images'], data['labels'], data['classes']
        # It's faster to load+process uint8 data than to load preprocessed fp16 data
        self.images = (self.images.half() / 255).permute(0, 3, 1, 2).to(memory_format=torch.channels_last)

        self.normalize = T.Normalize(CIFAR_MEAN, CIFAR_STD)
        self.proc_images = {} # Saved results of image processing to be done on the first epoch
        self.epoch = 0

        self.aug = aug or {}
        for k in self.aug.keys():
            assert k in ['flip', 'translate'], 'Unrecognized key: %s' % k

        self.batch_size = batch_size
        self.drop_last = train if drop_last is None else drop_last
        self.shuffle = train if shuffle is None else shuffle

    def __len__(self):
        return len(self.images)//self.batch_size if self.drop_last else ceil(len(self.images)/self.batch_size)

    def __iter__(self):

        if self.epoch == 0:
            images = self.proc_images['norm'] = self.normalize(self.images)
            # Pre-flip images in order to do every-other epoch flipping scheme
            if self.aug.get('flip', False):
                images = self.proc_images['flip'] = batch_flip_lr(images)
            # Pre-pad images to save time when doing random translation
            pad = self.aug.get('translate', 0)
            if pad > 0:
                self.proc_images['pad'] = F.pad(images, (pad,)*4, 'reflect')

        if self.aug.get('translate', 0) > 0:
            images = batch_crop(self.proc_images['pad'], self.images.shape[-2])
        elif self.aug.get('flip', False):
            images = self.proc_images['flip']
        else:
            images = self.proc_images['norm']
        # Flip all images together every other epoch. This increases diversity relative to random flipping
        if self.aug.get('flip', False):
            if self.epoch % 2 == 1:
                images = images.flip(-1)

        self.epoch += 1

        indices = (torch.randperm if self.shuffle else torch.arange)(len(images), device=images.device)
        for i in range(len(self)):
            idxs = indices[i*self.batch_size:(i+1)*self.batch_size]
            yield (images[idxs], self.labels[idxs])

#############################################
#            Network Components             #
#############################################

class Flatten(nn.Module):
    def forward(self, x):
        return x.view(x.size(0), -1)

class Mul(nn.Module):
    def __init__(self, scale):
        super().__init__()
        self.scale = scale
    def forward(self, x):
        return x * self.scale

class BatchNorm(nn.BatchNorm2d):
    def __init__(self, num_features, momentum, eps=1e-12,
                 weight=False, bias=True):
        super().__init__(num_features, eps=eps, momentum=1-momentum)
        self.weight.requires_grad = weight
        self.bias.requires_grad = bias
        # Note that PyTorch already initializes the weights to one and bias to zero

class Conv(nn.Conv2d):
    def __init__(self, in_channels, out_channels, kernel_size=3, padding='same', bias=False):
        super().__init__(in_channels, out_channels, kernel_size=kernel_size, padding=padding, bias=bias)

    def reset_parameters(self):
        super().reset_parameters()
        if self.bias is not None:
            self.bias.data.zero_()
        w = self.weight.data
        torch.nn.init.dirac_(w[:w.size(1)])

class ConvGroup(nn.Module):
    def __init__(self, channels_in, channels_out, batchnorm_momentum):
        super().__init__()
        self.conv1 = Conv(channels_in,  channels_out)
        self.pool = nn.MaxPool2d(2)
        self.norm1 = BatchNorm(channels_out, batchnorm_momentum)
        self.conv2 = Conv(channels_out, channels_out)
        self.norm2 = BatchNorm(channels_out, batchnorm_momentum)
        self.activ = nn.GELU()

    def forward(self, x):
        x = self.conv1(x)
        x = self.pool(x)
        x = self.norm1(x)
        x = self.activ(x)
        x = self.conv2(x)
        x = self.norm2(x)
        x = self.activ(x)
        return x

#############################################
#            Network Definition             #
#############################################

def make_net():
    widths = hyp['net']['widths']
    batchnorm_momentum = hyp['net']['batchnorm_momentum']
    whiten_kernel_size = 2
    whiten_width = 2 * 3 * whiten_kernel_size**2
    net = nn.Sequential(
        Conv(3, whiten_width, whiten_kernel_size, padding=0, bias=True),
        nn.GELU(),
        ConvGroup(whiten_width,     widths['block1'], batchnorm_momentum),
        ConvGroup(widths['block1'], widths['block2'], batchnorm_momentum),
        ConvGroup(widths['block2'], widths['block3'], batchnorm_momentum),
        nn.MaxPool2d(3),
        Flatten(),
        nn.Linear(widths['block3'], 10, bias=False),
        Mul(hyp['net']['scaling_factor']),
    )
    net[0].weight.requires_grad = False
    net = net.half().cuda()
    net = net.to(memory_format=torch.channels_last)
    for mod in net.modules():
        if isinstance(mod, BatchNorm):
            mod.float()
    return net

#############################################
#       Whitening Conv Initialization       #
#############################################

def get_patches(x, patch_shape):
    c, (h, w) = x.shape[1], patch_shape
    return x.unfold(2,h,1).unfold(3,w,1).transpose(1,3).reshape(-1,c,h,w).float()

def get_whitening_parameters(patches):
    n,c,h,w = patches.shape
    patches_flat = patches.view(n, -1)
    est_patch_covariance = (patches_flat.T @ patches_flat) / n
    eigenvalues, eigenvectors = torch.linalg.eigh(est_patch_covariance, UPLO='U')
    return eigenvalues.flip(0).view(-1, 1, 1, 1), eigenvectors.T.reshape(c*h*w,c,h,w).flip(0)

def init_whitening_conv(layer, train_set, eps=5e-4):
    patches = get_patches(train_set, patch_shape=layer.weight.data.shape[2:])
    eigenvalues, eigenvectors = get_whitening_parameters(patches)
    eigenvectors_scaled = eigenvectors / torch.sqrt(eigenvalues + eps)
    layer.weight.data[:] = torch.cat((eigenvectors_scaled, -eigenvectors_scaled))

############################################
#                Lookahead                 #
############################################

class LookaheadState:
    def __init__(self, net):
        self.net_ema = {k: v.clone() for k, v in net.state_dict().items()}

    def update(self, net, decay):
        for ema_param, net_param in zip(self.net_ema.values(), net.state_dict().values()):
            if net_param.dtype in (torch.half, torch.float):
                ema_param.lerp_(net_param, 1-decay)
                net_param.copy_(ema_param)

############################################
#                 Logging                  #
############################################

def print_columns(columns_list, is_head=False, is_final_entry=False):
    print_string = ''
    for col in columns_list:
        print_string += '|  %s  ' % col
    print_string += '|'
    if is_head:
        print('-'*len(print_string))
    print(print_string)
    if is_head or is_final_entry:
        print('-'*len(print_string))

logging_columns_list = ['run   ', 'epoch', 'train_loss', 'train_acc', 'val_acc', 'tta_val_acc', 'total_time_seconds']
def print_training_details(variables, is_final_entry):
    formatted = []
    for col in logging_columns_list:
        var = variables.get(col.strip(), None)
        if type(var) in (int, str):
            res = str(var)
        elif type(var) is float:
            res = '{:0.4f}'.format(var)
        else:
            assert var is None
            res = ''
        formatted.append(res.rjust(len(col)))
    print_columns(formatted, is_final_entry=is_final_entry)

############################################
#               Evaluation                 #
############################################

def infer(model, loader, tta_level=0):

    # Test-time augmentation strategy (for tta_level=2):
    # 1. Flip/mirror the image left-to-right (50% of the time).
    # 2. Translate the image by one pixel either up-and-left or down-and-right (50% of the time,
    #    i.e. both happen 25% of the time).
    #
    # This creates 6 views per image (left/right times the two translations and no-translation),
    # which we evaluate and then weight according to the given probabilities.

    def infer_basic(inputs, net):
        return net(inputs).clone()

    def infer_mirror(inputs, net):
        return 0.5 * net(inputs) + 0.5 * net(inputs.flip(-1))

    def infer_mirror_translate(inputs, net):
        logits = infer_mirror(inputs, net)
        pad = 1
        padded_inputs = F.pad(inputs, (pad,)*4, 'reflect')
        inputs_translate_list = [
            padded_inputs[:, :, 0:32, 0:32],
            padded_inputs[:, :, 2:34, 2:34],
        ]
        logits_translate_list = [infer_mirror(inputs_translate, net)
                                 for inputs_translate in inputs_translate_list]
        logits_translate = torch.stack(logits_translate_list).mean(0)
        return 0.5 * logits + 0.5 * logits_translate

    model.eval()
    test_images = loader.normalize(loader.images)
    infer_fn = [infer_basic, infer_mirror, infer_mirror_translate][tta_level]
    with torch.no_grad():
        return torch.cat([infer_fn(inputs, model) for inputs in test_images.split(2000)])

def evaluate(model, loader, tta_level=0):
    logits = infer(model, loader, tta_level)
    return (logits.argmax(1) == loader.labels).float().mean().item()

############################################
#                Training                  #
############################################

def main(run):

    batch_size = hyp['opt']['batch_size']
    epochs = hyp['opt']['train_epochs']
    momentum = hyp['opt']['momentum']
    # Assuming gradients are constant in time, for Nesterov momentum, the below ratio is how much
    # larger the default steps will be than the underlying per-example gradients. We divide the
    # learning rate by this ratio in order to ensure steps are the same scale as gradients, regardless
    # of the choice of momentum.
    kilostep_scale = 1024 * (1 + 1 / (1 - momentum))
    lr = hyp['opt']['lr'] / kilostep_scale # un-decoupled learning rate for PyTorch SGD
    wd = hyp['opt']['weight_decay'] * batch_size / kilostep_scale
    lr_biases = lr * hyp['opt']['bias_scaler']

    loss_fn = nn.CrossEntropyLoss(label_smoothing=hyp['opt']['label_smoothing'], reduction='none')
    test_loader = CifarLoader('cifar10', train=False, batch_size=2000)
    train_loader = CifarLoader('cifar10', train=True, batch_size=batch_size, aug=hyp['aug'])
    if run == 'warmup':
        # The only purpose of the first run is to warmup, so we can use dummy data
        train_loader.labels = torch.randint(0, 10, size=(len(train_loader.labels),), device=train_loader.labels.device)
    total_train_steps = ceil(len(train_loader) * epochs)

    model = make_net()
    # Keep a direct reference to the whitening conv layer before any compilation
    whitening_layer = model[0]

    current_steps = 0

    norm_biases = [p for k, p in model.named_parameters() if 'norm' in k and p.requires_grad]
    other_params = [p for k, p in model.named_parameters() if 'norm' not in k and p.requires_grad]
    param_configs = [dict(params=norm_biases, lr=lr_biases, weight_decay=wd/lr_biases),
                     dict(params=other_params, lr=lr, weight_decay=wd/lr)]
    optimizer = torch.optim.SGD(param_configs, momentum=momentum, nesterov=True)

    def get_lr(step):
        warmup_steps = int(total_train_steps * 0.23)
        warmdown_steps = total_train_steps - warmup_steps
        if step < warmup_steps:
            frac = step / warmup_steps
            return 0.2 * (1 - frac) + 1.0 * frac
        else:
            frac = (step - warmup_steps) / warmdown_steps
            return 1.0 * (1 - frac) + 0.07 * frac
    scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, get_lr)

    alpha_schedule = 0.95**5 * (torch.arange(total_train_steps+1) / total_train_steps)**3
    lookahead_state = LookaheadState(model)

    # For accurately timing GPU code
    starter = torch.cuda.Event(enable_timing=True)
    ender = torch.cuda.Event(enable_timing=True)
    total_time_seconds = 0.0

    # Initialize the whitening layer using training images
    starter.record()
    train_images = train_loader.normalize(train_loader.images[:5000])
    init_whitening_conv(whitening_layer, train_images)
    ender.record()
    torch.cuda.synchronize()
    total_time_seconds += 1e-3 * starter.elapsed_time(ender)

    # Compile the model if needed
    if USE_COMPILE:
        model = torch.compile(model)


    for epoch in range(ceil(epochs)):

        whitening_layer.bias.requires_grad = (epoch < hyp['opt']['whiten_bias_epochs'])

        ####################
        #     Training     #
        ####################

        starter.record()

        model.train()
        for inputs, labels in train_loader:

            outputs = model(inputs)
            loss = loss_fn(outputs, labels).sum()
            optimizer.zero_grad(set_to_none=True)
            loss.backward()
            optimizer.step()
            scheduler.step()

            current_steps += 1

            if current_steps % 5 == 0:
                lookahead_state.update(model, decay=alpha_schedule[current_steps].item())

            if current_steps >= total_train_steps:
                if lookahead_state is not None:
                    lookahead_state.update(model, decay=1.0)
                break

        ender.record()
        torch.cuda.synchronize()
        total_time_seconds += 1e-3 * starter.elapsed_time(ender)

        ####################
        #    Evaluation    #
        ####################

        # Save the accuracy and loss from the last training batch of the epoch
        train_acc = (outputs.detach().argmax(1) == labels).float().mean().item()
        train_loss = loss.item() / batch_size
        val_acc = evaluate(model, test_loader, tta_level=0)
        print_training_details(locals(), is_final_entry=False)
        run = None # Only print the run number once

    ####################
    #  TTA Evaluation  #
    ####################

    starter.record()
    tta_val_acc = evaluate(model, test_loader, tta_level=hyp['net']['tta_level'])
    ender.record()
    torch.cuda.synchronize()
    total_time_seconds += 1e-3 * starter.elapsed_time(ender)

    epoch = 'eval'
    print_training_details(locals(), is_final_entry=True)

    return tta_val_acc, total_time_seconds

if __name__ == "__main__":
    with open(sys.argv[0]) as f:
        code = f.read()

    print_columns(logging_columns_list, is_head=True)
    main('warmup')
    results = torch.tensor([main(run) for run in range(25)])
    accs = results[:, 0]
    times = results[:, 1]
    print('Mean: %.4f    Std: %.4f' % (accs.mean(), accs.std()))
    print('Mean time: %.4f    Std time: %.4f' % (times.mean(), times.std()))

    # Add timestamp to log files
    timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')

    log = {
        'code': code,
        'accs': accs,
        'times': times,
        'timestamp': timestamp,
        'compile': USE_COMPILE,
    }
    
    # Add timestamp to log files
    timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
    log_dir = os.path.join('logs', f"{timestamp}_{uuid.uuid4()}")

    os.makedirs(log_dir, exist_ok=True)
    log_path = os.path.join(log_dir, 'log.pt')
    print(os.path.abspath(log_path))
    torch.save(log, os.path.join(log_dir, 'log.pt'))



====================================================================================================
RAW LOG DICTIONARY DUMP
====================================================================================================

{ 'accs': tensor([0.9387, 0.9424, 0.9411, 0.9414, 0.9402, 0.9391, 0.9412, 0.9389, 0.9400,
        0.9426, 0.9400, 0.9397, 0.9404, 0.9394, 0.9392, 0.9402, 0.9384, 0.9419,
        0.9413, 0.9398, 0.9404, 0.9414, 0.9409, 0.9389, 0.9405]),
  'code': '# Taken from '
          'https://github.com/KellerJordan/cifar10-airbench/blob/master/legacy/airbench94.py\n'
          '# Uncompiled variant of airbench94_compiled.py\n'
          '# 3.83s runtime on an A100; 0.36 PFLOPs.\n'
          '# Evidence: 94.01 average accuracy in n=1000 runs.\n'
          '#\n'
          '# We recorded the runtime of 3.83 seconds on an NVIDIA A100-SXM4-80GB with the '
          'following nvidia-smi:\n'
          '# NVIDIA-SMI 515.105.01   Driver Version: 515.105.01   CUDA Version: 11.7\n'
          "# torch.__version__ == '2.1.2+cu118'\n"
          '\n'
          '#############################################\n'
          '#            Setup/Hyperparameters          #\n'
          '#############################################\n'
          '\n'
          'import os\n'
          'import sys\n'
          'import uuid\n'
          'from math import ceil\n'
          '\n'
          'import torch\n'
          'from torch import nn\n'
          'import torch.nn.functional as F\n'
          'import torchvision\n'
          'import torchvision.transforms as T\n'
          'from datetime import datetime\n'
          '\n'
          'torch.backends.cudnn.benchmark = True\n'
          '\n'
          '\n'
          '\n'
          '# Set whether to precompile model with (precompiled baseline should be 3.29 as opposed '
          'to 3.83):\n'
          '# AIRBENCH_USE_COMPILE=0 python airbench94.py   uncompiled baseline\n'
          '# AIRBENCH_USE_COMPILE=1 python airbench94.py   compiled baseline\n'
          '\n'
          '# Or set for multiple runs with:\n'
          '# export AIRBENCH_USE_COMPILE=1\n'
          '# export AIRBENCH_USE_COMPILE=0\n'
          '\n'
          'USE_COMPILE = bool(int(os.environ.get("AIRBENCH_USE_COMPILE", "0")))\n'
          '\n'
          '# We express the main training hyperparameters (batch size, learning rate, momentum, '
          'and weight decay)\n'
          '# in decoupled form, so that each one can be tuned independently. This accomplishes the '
          'following:\n'
          '# * Assuming time-constant gradients, the average step size is decoupled from '
          'everything but the lr.\n'
          '# * The size of the weight decay update is decoupled from everything but the wd.\n'
          '# In constrast, normally when we increase the (Nesterov) momentum, this also scales up '
          'the step size\n'
          '# proportionally to 1 + 1 / (1 - momentum), meaning we cannot change momentum without '
          'having to re-tune\n'
          '# the learning rate. Similarly, normally when we increase the learning rate this also '
          'increases the size\n'
          '# of the weight decay, requiring a proportional decrease in the wd to maintain the same '
          'decay strength.\n'
          '#\n'
          '# The practical impact is that hyperparameter tuning is faster, since this '
          'parametrization allows each\n'
          '# one to be tuned independently. See '
          'https://myrtle.ai/learn/how-to-train-your-resnet-5-hyperparameters/.\n'
          '\n'
          'hyp = {\n'
          "    'opt': {\n"
          "        'train_epochs': 9.9,\n"
          "        'batch_size': 1024,\n"
          "        'lr': 11.5,                 # learning rate per 1024 examples\n"
          "        'momentum': 0.85,\n"
          "        'weight_decay': 0.0153,     # weight decay per 1024 examples (decoupled from "
          'learning rate)\n'
          "        'bias_scaler': 64.0,        # scales up learning rate (but not weight decay) "
          'for BatchNorm biases\n'
          "        'label_smoothing': 0.2,\n"
          "        'whiten_bias_epochs': 3,    # how many epochs to train the whitening layer bias "
          'before freezing\n'
          '    },\n'
          "    'aug': {\n"
          "        'flip': True,\n"
          "        'translate': 2,\n"
          '    },\n'
          "    'net': {\n"
          "        'widths': {\n"
          "            'block1': 64,\n"
          "            'block2': 256,\n"
          "            'block3': 256,\n"
          '        },\n'
          "        'batchnorm_momentum': 0.6,\n"
          "        'scaling_factor': 1/9,\n"
          "        'tta_level': 2,         # the level of test-time augmentation: 0=none, "
          '1=mirror, 2=mirror+translate\n'
          '    },\n'
          '}\n'
          '\n'
          '#############################################\n'
          '#                DataLoader                 #\n'
          '#############################################\n'
          '\n'
          'CIFAR_MEAN = torch.tensor((0.4914, 0.4822, 0.4465))\n'
          'CIFAR_STD = torch.tensor((0.2470, 0.2435, 0.2616))\n'
          '\n'
          'def batch_flip_lr(inputs):\n'
          '    flip_mask = (torch.rand(len(inputs), device=inputs.device) < 0.5).view(-1, 1, 1, '
          '1)\n'
          '    return torch.where(flip_mask, inputs.flip(-1), inputs)\n'
          '\n'
          'def batch_crop(images, crop_size):\n'
          '    r = (images.size(-1) - crop_size)//2\n'
          '    shifts = torch.randint(-r, r+1, size=(len(images), 2), device=images.device)\n'
          '    images_out = torch.empty((len(images), 3, crop_size, crop_size), '
          'device=images.device, dtype=images.dtype)\n'
          '    # The two cropping methods in this if-else produce equivalent results, but the '
          'second is faster for r > 2.\n'
          '    if r <= 2:\n'
          '        for sy in range(-r, r+1):\n'
          '            for sx in range(-r, r+1):\n'
          '                mask = (shifts[:, 0] == sy) & (shifts[:, 1] == sx)\n'
          '                images_out[mask] = images[mask, :, r+sy:r+sy+crop_size, '
          'r+sx:r+sx+crop_size]\n'
          '    else:\n'
          '        images_tmp = torch.empty((len(images), 3, crop_size, crop_size+2*r), '
          'device=images.device, dtype=images.dtype)\n'
          '        for s in range(-r, r+1):\n'
          '            mask = (shifts[:, 0] == s)\n'
          '            images_tmp[mask] = images[mask, :, r+s:r+s+crop_size, :]\n'
          '        for s in range(-r, r+1):\n'
          '            mask = (shifts[:, 1] == s)\n'
          '            images_out[mask] = images_tmp[mask, :, :, r+s:r+s+crop_size]\n'
          '    return images_out\n'
          '\n'
          'class CifarLoader:\n'
          '\n'
          '    def __init__(self, path, train=True, batch_size=500, aug=None, drop_last=None, '
          'shuffle=None, gpu=0):\n'
          "        data_path = os.path.join(path, 'train.pt' if train else 'test.pt')\n"
          '        if not os.path.exists(data_path):\n'
          '            dset = torchvision.datasets.CIFAR10(path, download=True, train=train)\n'
          '            images = torch.tensor(dset.data)\n'
          '            labels = torch.tensor(dset.targets)\n'
          "            torch.save({'images': images, 'labels': labels, 'classes': dset.classes}, "
          'data_path)\n'
          '\n'
          '        data = torch.load(data_path, map_location=torch.device(gpu))\n'
          "        self.images, self.labels, self.classes = data['images'], data['labels'], "
          "data['classes']\n"
          "        # It's faster to load+process uint8 data than to load preprocessed fp16 data\n"
          '        self.images = (self.images.half() / 255).permute(0, 3, 1, '
          '2).to(memory_format=torch.channels_last)\n'
          '\n'
          '        self.normalize = T.Normalize(CIFAR_MEAN, CIFAR_STD)\n'
          '        self.proc_images = {} # Saved results of image processing to be done on the '
          'first epoch\n'
          '        self.epoch = 0\n'
          '\n'
          '        self.aug = aug or {}\n'
          '        for k in self.aug.keys():\n'
          "            assert k in ['flip', 'translate'], 'Unrecognized key: %s' % k\n"
          '\n'
          '        self.batch_size = batch_size\n'
          '        self.drop_last = train if drop_last is None else drop_last\n'
          '        self.shuffle = train if shuffle is None else shuffle\n'
          '\n'
          '    def __len__(self):\n'
          '        return len(self.images)//self.batch_size if self.drop_last else '
          'ceil(len(self.images)/self.batch_size)\n'
          '\n'
          '    def __iter__(self):\n'
          '\n'
          '        if self.epoch == 0:\n'
          "            images = self.proc_images['norm'] = self.normalize(self.images)\n"
          '            # Pre-flip images in order to do every-other epoch flipping scheme\n'
          "            if self.aug.get('flip', False):\n"
          "                images = self.proc_images['flip'] = batch_flip_lr(images)\n"
          '            # Pre-pad images to save time when doing random translation\n'
          "            pad = self.aug.get('translate', 0)\n"
          '            if pad > 0:\n'
          "                self.proc_images['pad'] = F.pad(images, (pad,)*4, 'reflect')\n"
          '\n'
          "        if self.aug.get('translate', 0) > 0:\n"
          "            images = batch_crop(self.proc_images['pad'], self.images.shape[-2])\n"
          "        elif self.aug.get('flip', False):\n"
          "            images = self.proc_images['flip']\n"
          '        else:\n'
          "            images = self.proc_images['norm']\n"
          '        # Flip all images together every other epoch. This increases diversity relative '
          'to random flipping\n'
          "        if self.aug.get('flip', False):\n"
          '            if self.epoch % 2 == 1:\n'
          '                images = images.flip(-1)\n'
          '\n'
          '        self.epoch += 1\n'
          '\n'
          '        indices = (torch.randperm if self.shuffle else torch.arange)(len(images), '
          'device=images.device)\n'
          '        for i in range(len(self)):\n'
          '            idxs = indices[i*self.batch_size:(i+1)*self.batch_size]\n'
          '            yield (images[idxs], self.labels[idxs])\n'
          '\n'
          '#############################################\n'
          '#            Network Components             #\n'
          '#############################################\n'
          '\n'
          'class Flatten(nn.Module):\n'
          '    def forward(self, x):\n'
          '        return x.view(x.size(0), -1)\n'
          '\n'
          'class Mul(nn.Module):\n'
          '    def __init__(self, scale):\n'
          '        super().__init__()\n'
          '        self.scale = scale\n'
          '    def forward(self, x):\n'
          '        return x * self.scale\n'
          '\n'
          'class BatchNorm(nn.BatchNorm2d):\n'
          '    def __init__(self, num_features, momentum, eps=1e-12,\n'
          '                 weight=False, bias=True):\n'
          '        super().__init__(num_features, eps=eps, momentum=1-momentum)\n'
          '        self.weight.requires_grad = weight\n'
          '        self.bias.requires_grad = bias\n'
          '        # Note that PyTorch already initializes the weights to one and bias to zero\n'
          '\n'
          'class Conv(nn.Conv2d):\n'
          "    def __init__(self, in_channels, out_channels, kernel_size=3, padding='same', "
          'bias=False):\n'
          '        super().__init__(in_channels, out_channels, kernel_size=kernel_size, '
          'padding=padding, bias=bias)\n'
          '\n'
          '    def reset_parameters(self):\n'
          '        super().reset_parameters()\n'
          '        if self.bias is not None:\n'
          '            self.bias.data.zero_()\n'
          '        w = self.weight.data\n'
          '        torch.nn.init.dirac_(w[:w.size(1)])\n'
          '\n'
          'class ConvGroup(nn.Module):\n'
          '    def __init__(self, channels_in, channels_out, batchnorm_momentum):\n'
          '        super().__init__()\n'
          '        self.conv1 = Conv(channels_in,  channels_out)\n'
          '        self.pool = nn.MaxPool2d(2)\n'
          '        self.norm1 = BatchNorm(channels_out, batchnorm_momentum)\n'
          '        self.conv2 = Conv(channels_out, channels_out)\n'
          '        self.norm2 = BatchNorm(channels_out, batchnorm_momentum)\n'
          '        self.activ = nn.GELU()\n'
          '\n'
          '    def forward(self, x):\n'
          '        x = self.conv1(x)\n'
          '        x = self.pool(x)\n'
          '        x = self.norm1(x)\n'
          '        x = self.activ(x)\n'
          '        x = self.conv2(x)\n'
          '        x = self.norm2(x)\n'
          '        x = self.activ(x)\n'
          '        return x\n'
          '\n'
          '#############################################\n'
          '#            Network Definition             #\n'
          '#############################################\n'
          '\n'
          'def make_net():\n'
          "    widths = hyp['net']['widths']\n"
          "    batchnorm_momentum = hyp['net']['batchnorm_momentum']\n"
          '    whiten_kernel_size = 2\n'
          '    whiten_width = 2 * 3 * whiten_kernel_size**2\n'
          '    net = nn.Sequential(\n'
          '        Conv(3, whiten_width, whiten_kernel_size, padding=0, bias=True),\n'
          '        nn.GELU(),\n'
          "        ConvGroup(whiten_width,     widths['block1'], batchnorm_momentum),\n"
          "        ConvGroup(widths['block1'], widths['block2'], batchnorm_momentum),\n"
          "        ConvGroup(widths['block2'], widths['block3'], batchnorm_momentum),\n"
          '        nn.MaxPool2d(3),\n'
          '        Flatten(),\n'
          "        nn.Linear(widths['block3'], 10, bias=False),\n"
          "        Mul(hyp['net']['scaling_factor']),\n"
          '    )\n'
          '    net[0].weight.requires_grad = False\n'
          '    net = net.half().cuda()\n'
          '    net = net.to(memory_format=torch.channels_last)\n'
          '    for mod in net.modules():\n'
          '        if isinstance(mod, BatchNorm):\n'
          '            mod.float()\n'
          '    return net\n'
          '\n'
          '#############################################\n'
          '#       Whitening Conv Initialization       #\n'
          '#############################################\n'
          '\n'
          'def get_patches(x, patch_shape):\n'
          '    c, (h, w) = x.shape[1], patch_shape\n'
          '    return x.unfold(2,h,1).unfold(3,w,1).transpose(1,3).reshape(-1,c,h,w).float()\n'
          '\n'
          'def get_whitening_parameters(patches):\n'
          '    n,c,h,w = patches.shape\n'
          '    patches_flat = patches.view(n, -1)\n'
          '    est_patch_covariance = (patches_flat.T @ patches_flat) / n\n'
          "    eigenvalues, eigenvectors = torch.linalg.eigh(est_patch_covariance, UPLO='U')\n"
          '    return eigenvalues.flip(0).view(-1, 1, 1, 1), '
          'eigenvectors.T.reshape(c*h*w,c,h,w).flip(0)\n'
          '\n'
          'def init_whitening_conv(layer, train_set, eps=5e-4):\n'
          '    patches = get_patches(train_set, patch_shape=layer.weight.data.shape[2:])\n'
          '    eigenvalues, eigenvectors = get_whitening_parameters(patches)\n'
          '    eigenvectors_scaled = eigenvectors / torch.sqrt(eigenvalues + eps)\n'
          '    layer.weight.data[:] = torch.cat((eigenvectors_scaled, -eigenvectors_scaled))\n'
          '\n'
          '############################################\n'
          '#                Lookahead                 #\n'
          '############################################\n'
          '\n'
          'class LookaheadState:\n'
          '    def __init__(self, net):\n'
          '        self.net_ema = {k: v.clone() for k, v in net.state_dict().items()}\n'
          '\n'
          '    def update(self, net, decay):\n'
          '        for ema_param, net_param in zip(self.net_ema.values(), '
          'net.state_dict().values()):\n'
          '            if net_param.dtype in (torch.half, torch.float):\n'
          '                ema_param.lerp_(net_param, 1-decay)\n'
          '                net_param.copy_(ema_param)\n'
          '\n'
          '############################################\n'
          '#                 Logging                  #\n'
          '############################################\n'
          '\n'
          'def print_columns(columns_list, is_head=False, is_final_entry=False):\n'
          "    print_string = ''\n"
          '    for col in columns_list:\n'
          "        print_string += '|  %s  ' % col\n"
          "    print_string += '|'\n"
          '    if is_head:\n'
          "        print('-'*len(print_string))\n"
          '    print(print_string)\n'
          '    if is_head or is_final_entry:\n'
          "        print('-'*len(print_string))\n"
          '\n'
          "logging_columns_list = ['run   ', 'epoch', 'train_loss', 'train_acc', 'val_acc', "
          "'tta_val_acc', 'total_time_seconds']\n"
          'def print_training_details(variables, is_final_entry):\n'
          '    formatted = []\n'
          '    for col in logging_columns_list:\n'
          '        var = variables.get(col.strip(), None)\n'
          '        if type(var) in (int, str):\n'
          '            res = str(var)\n'
          '        elif type(var) is float:\n'
          "            res = '{:0.4f}'.format(var)\n"
          '        else:\n'
          '            assert var is None\n'
          "            res = ''\n"
          '        formatted.append(res.rjust(len(col)))\n'
          '    print_columns(formatted, is_final_entry=is_final_entry)\n'
          '\n'
          '############################################\n'
          '#               Evaluation                 #\n'
          '############################################\n'
          '\n'
          'def infer(model, loader, tta_level=0):\n'
          '\n'
          '    # Test-time augmentation strategy (for tta_level=2):\n'
          '    # 1. Flip/mirror the image left-to-right (50% of the time).\n'
          '    # 2. Translate the image by one pixel either up-and-left or down-and-right (50% of '
          'the time,\n'
          '    #    i.e. both happen 25% of the time).\n'
          '    #\n'
          '    # This creates 6 views per image (left/right times the two translations and '
          'no-translation),\n'
          '    # which we evaluate and then weight according to the given probabilities.\n'
          '\n'
          '    def infer_basic(inputs, net):\n'
          '        return net(inputs).clone()\n'
          '\n'
          '    def infer_mirror(inputs, net):\n'
          '        return 0.5 * net(inputs) + 0.5 * net(inputs.flip(-1))\n'
          '\n'
          '    def infer_mirror_translate(inputs, net):\n'
          '        logits = infer_mirror(inputs, net)\n'
          '        pad = 1\n'
          "        padded_inputs = F.pad(inputs, (pad,)*4, 'reflect')\n"
          '        inputs_translate_list = [\n'
          '            padded_inputs[:, :, 0:32, 0:32],\n'
          '            padded_inputs[:, :, 2:34, 2:34],\n'
          '        ]\n'
          '        logits_translate_list = [infer_mirror(inputs_translate, net)\n'
          '                                 for inputs_translate in inputs_translate_list]\n'
          '        logits_translate = torch.stack(logits_translate_list).mean(0)\n'
          '        return 0.5 * logits + 0.5 * logits_translate\n'
          '\n'
          '    model.eval()\n'
          '    test_images = loader.normalize(loader.images)\n'
          '    infer_fn = [infer_basic, infer_mirror, infer_mirror_translate][tta_level]\n'
          '    with torch.no_grad():\n'
          '        return torch.cat([infer_fn(inputs, model) for inputs in '
          'test_images.split(2000)])\n'
          '\n'
          'def evaluate(model, loader, tta_level=0):\n'
          '    logits = infer(model, loader, tta_level)\n'
          '    return (logits.argmax(1) == loader.labels).float().mean().item()\n'
          '\n'
          '############################################\n'
          '#                Training                  #\n'
          '############################################\n'
          '\n'
          'def main(run):\n'
          '\n'
          "    batch_size = hyp['opt']['batch_size']\n"
          "    epochs = hyp['opt']['train_epochs']\n"
          "    momentum = hyp['opt']['momentum']\n"
          '    # Assuming gradients are constant in time, for Nesterov momentum, the below ratio '
          'is how much\n'
          '    # larger the default steps will be than the underlying per-example gradients. We '
          'divide the\n'
          '    # learning rate by this ratio in order to ensure steps are the same scale as '
          'gradients, regardless\n'
          '    # of the choice of momentum.\n'
          '    kilostep_scale = 1024 * (1 + 1 / (1 - momentum))\n'
          "    lr = hyp['opt']['lr'] / kilostep_scale # un-decoupled learning rate for PyTorch "
          'SGD\n'
          "    wd = hyp['opt']['weight_decay'] * batch_size / kilostep_scale\n"
          "    lr_biases = lr * hyp['opt']['bias_scaler']\n"
          '\n'
          "    loss_fn = nn.CrossEntropyLoss(label_smoothing=hyp['opt']['label_smoothing'], "
          "reduction='none')\n"
          "    test_loader = CifarLoader('cifar10', train=False, batch_size=2000)\n"
          "    train_loader = CifarLoader('cifar10', train=True, batch_size=batch_size, "
          "aug=hyp['aug'])\n"
          "    if run == 'warmup':\n"
          '        # The only purpose of the first run is to warmup, so we can use dummy data\n'
          '        train_loader.labels = torch.randint(0, 10, size=(len(train_loader.labels),), '
          'device=train_loader.labels.device)\n'
          '    total_train_steps = ceil(len(train_loader) * epochs)\n'
          '\n'
          '    model = make_net()\n'
          '    # Keep a direct reference to the whitening conv layer before any compilation\n'
          '    whitening_layer = model[0]\n'
          '\n'
          '    current_steps = 0\n'
          '\n'
          "    norm_biases = [p for k, p in model.named_parameters() if 'norm' in k and "
          'p.requires_grad]\n'
          "    other_params = [p for k, p in model.named_parameters() if 'norm' not in k and "
          'p.requires_grad]\n'
          '    param_configs = [dict(params=norm_biases, lr=lr_biases, '
          'weight_decay=wd/lr_biases),\n'
          '                     dict(params=other_params, lr=lr, weight_decay=wd/lr)]\n'
          '    optimizer = torch.optim.SGD(param_configs, momentum=momentum, nesterov=True)\n'
          '\n'
          '    def get_lr(step):\n'
          '        warmup_steps = int(total_train_steps * 0.23)\n'
          '        warmdown_steps = total_train_steps - warmup_steps\n'
          '        if step < warmup_steps:\n'
          '            frac = step / warmup_steps\n'
          '            return 0.2 * (1 - frac) + 1.0 * frac\n'
          '        else:\n'
          '            frac = (step - warmup_steps) / warmdown_steps\n'
          '            return 1.0 * (1 - frac) + 0.07 * frac\n'
          '    scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, get_lr)\n'
          '\n'
          '    alpha_schedule = 0.95**5 * (torch.arange(total_train_steps+1) / '
          'total_train_steps)**3\n'
          '    lookahead_state = LookaheadState(model)\n'
          '\n'
          '    # For accurately timing GPU code\n'
          '    starter = torch.cuda.Event(enable_timing=True)\n'
          '    ender = torch.cuda.Event(enable_timing=True)\n'
          '    total_time_seconds = 0.0\n'
          '\n'
          '    # Initialize the whitening layer using training images\n'
          '    starter.record()\n'
          '    train_images = train_loader.normalize(train_loader.images[:5000])\n'
          '    init_whitening_conv(whitening_layer, train_images)\n'
          '    ender.record()\n'
          '    torch.cuda.synchronize()\n'
          '    total_time_seconds += 1e-3 * starter.elapsed_time(ender)\n'
          '\n'
          '    # Compile the model if needed\n'
          '    if USE_COMPILE:\n'
          '        model = torch.compile(model)\n'
          '\n'
          '\n'
          '    for epoch in range(ceil(epochs)):\n'
          '\n'
          '        whitening_layer.bias.requires_grad = (epoch < '
          "hyp['opt']['whiten_bias_epochs'])\n"
          '\n'
          '        ####################\n'
          '        #     Training     #\n'
          '        ####################\n'
          '\n'
          '        starter.record()\n'
          '\n'
          '        model.train()\n'
          '        for inputs, labels in train_loader:\n'
          '\n'
          '            outputs = model(inputs)\n'
          '            loss = loss_fn(outputs, labels).sum()\n'
          '            optimizer.zero_grad(set_to_none=True)\n'
          '            loss.backward()\n'
          '            optimizer.step()\n'
          '            scheduler.step()\n'
          '\n'
          '            current_steps += 1\n'
          '\n'
          '            if current_steps % 5 == 0:\n'
          '                lookahead_state.update(model, '
          'decay=alpha_schedule[current_steps].item())\n'
          '\n'
          '            if current_steps >= total_train_steps:\n'
          '                if lookahead_state is not None:\n'
          '                    lookahead_state.update(model, decay=1.0)\n'
          '                break\n'
          '\n'
          '        ender.record()\n'
          '        torch.cuda.synchronize()\n'
          '        total_time_seconds += 1e-3 * starter.elapsed_time(ender)\n'
          '\n'
          '        ####################\n'
          '        #    Evaluation    #\n'
          '        ####################\n'
          '\n'
          '        # Save the accuracy and loss from the last training batch of the epoch\n'
          '        train_acc = (outputs.detach().argmax(1) == labels).float().mean().item()\n'
          '        train_loss = loss.item() / batch_size\n'
          '        val_acc = evaluate(model, test_loader, tta_level=0)\n'
          '        print_training_details(locals(), is_final_entry=False)\n'
          '        run = None # Only print the run number once\n'
          '\n'
          '    ####################\n'
          '    #  TTA Evaluation  #\n'
          '    ####################\n'
          '\n'
          '    starter.record()\n'
          "    tta_val_acc = evaluate(model, test_loader, tta_level=hyp['net']['tta_level'])\n"
          '    ender.record()\n'
          '    torch.cuda.synchronize()\n'
          '    total_time_seconds += 1e-3 * starter.elapsed_time(ender)\n'
          '\n'
          "    epoch = 'eval'\n"
          '    print_training_details(locals(), is_final_entry=True)\n'
          '\n'
          '    return tta_val_acc, total_time_seconds\n'
          '\n'
          'if __name__ == "__main__":\n'
          '    with open(sys.argv[0]) as f:\n'
          '        code = f.read()\n'
          '\n'
          '    print_columns(logging_columns_list, is_head=True)\n'
          "    main('warmup')\n"
          '    results = torch.tensor([main(run) for run in range(25)])\n'
          '    accs = results[:, 0]\n'
          '    times = results[:, 1]\n'
          "    print('Mean: %.4f    Std: %.4f' % (accs.mean(), accs.std()))\n"
          "    print('Mean time: %.4f    Std time: %.4f' % (times.mean(), times.std()))\n"
          '\n'
          '    # Add timestamp to log files\n'
          "    timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')\n"
          '\n'
          '    log = {\n'
          "        'code': code,\n"
          "        'accs': accs,\n"
          "        'times': times,\n"
          "        'timestamp': timestamp,\n"
          "        'compile': USE_COMPILE,\n"
          '    }\n'
          '    \n'
          '    # Add timestamp to log files\n'
          "    timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')\n"
          '    log_dir = os.path.join(\'logs\', f"{timestamp}_{uuid.uuid4()}")\n'
          '\n'
          '    os.makedirs(log_dir, exist_ok=True)\n'
          "    log_path = os.path.join(log_dir, 'log.pt')\n"
          '    print(os.path.abspath(log_path))\n'
          "    torch.save(log, os.path.join(log_dir, 'log.pt'))\n"
          '\n',
  'compile': True,
  'times': tensor([3.8940, 3.8111, 3.8195, 3.8291, 3.8392, 3.9352, 3.8502, 3.8588, 3.8613,
        3.8665, 3.8698, 3.8758, 3.9625, 3.8808, 3.8841, 3.8861, 3.8888, 3.8909,
        3.9841, 3.8960, 3.8953, 3.9023, 3.9026, 3.9006, 3.9017]),
  'timestamp': '20251129-021144'}